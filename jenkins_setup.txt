Setup CI server inside the Kubernetes cluster and maintain High availability of jobs created

Prerequisites and Setup -

1. Install Rancher - to build custom Jenkins images(in a Linux host)
2. Docker Hub account - An account with a container image repository to push the custom images for our Jenkins master and agents

Build Custom images for Jenkins -

Build custom images for our Jenkins components and push them to Docker Hub.
Install Rancher on the master node.

Install Rancher - sudo docker run -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher

Access Rancher on browser by typing 'localhost' in URL address field

Write the Jenkins Master Dockerfile - Dockerfile-jenkins-master

vi Dockerfile-jenkins-master

FROM jenkins/jenkins:lts

# Plugins for better UX (not mandatory)
RUN /usr/local/bin/install-plugins.sh ansicolor
RUN /usr/local/bin/install-plugins.sh greenballs

# Plugin for scaling Jenkins agents
RUN /usr/local/bin/install-plugins.sh kubernetes

USER jenkins

=> The above instructions use the main Jenkins Docker image as a base and configure the plugins we will use to deploy onto a Kubernetes cluster.

Write the Jenkins Agent Dockerfiles

Two agent images are created here to demonstrate how Jenkins can correctly identify the correct agent to provision for each job.

Create an empty file in the current directory. This would serve as an identifier when the file is copied to the image for each agent which is built.

touch empty-test-file

Create a new Dockerfile for the first agent image:

vi Dockerfile-jenkins-slave-jnlp1

FROM jenkins/jnlp-slave

# For testing purpose only
COPY empty-test-file /jenkins-slave1

ENTRYPOINT ["jenkins-slave"]

This image will copy the empty file to a unique name to identify the agent being used.
 
Now, the second agent. This is identical to the previous agent but includes a different file identifier.

vi Dockerfile-jenkins-slave-jnlp2

FROM jenkins/jnlp-slave

# For testing purpose only
COPY empty-test-file /jenkins-slave2

ENTRYPOINT ["jenkins-slave"]

Build the images and push to Docker Hub

docker build -f Dockerfile-jenkins-master -t pvijaya/jenkins-master .

Verify - docker images

Login to Docker with credentials -

docker login

Push the image to Docker Hub account: docker push pvijaya/jenkins-master 

Build two images for the Jenkins JNLP agents -

docker build -f Dockerfile-jenkins-slave-jnlp1 -t pvijaya/jenkins-slave-jnlp1 .
docker push pvijaya/jenkins-slave-jnlp1

docker build -f Dockerfile-jenkins-slave-jnlp2 -t pvijaya/jenkins-slave-jnlp2 .
docker push pvijaya/jenkins-slave-jnlp2 

Deploying Jenkins to the cluster -

Deploy Jenkins master and create some services. Start by creating a file to define the Jenkins deployment.

vi deployment.yml

apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: jenkins
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: jenkins
    spec:
      containers:
        - name: jenkins
          image: pvijaya/jenkins-master
          env:
            - name: JAVA_OPTS
              value: -Djenkins.install.runSetupWizard=false
          ports:
            - name: http-port
              containerPort: 8080
            - name: jnlp-port
              containerPort: 50000
          volumeMounts:
            - name: jenkins-home
              mountPath: /var/jenkins_home
      volumes:
        - name: jenkins-home
          emptyDir: {}

Create a file to configure two services.

One is a LoadBalancer service which will provision a public IP allowing Jenkins to be accessed from the Internet. The other is ClusterIP service needed for internal communication between master and agents that will be provisioned.

vi service.yml 

apiVersion: v1
kind: Service
metadata:
  name: jenkins
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app: jenkins

---

apiVersion: v1
kind: Service
metadata:
  name: jenkins-jnlp
spec:
  type: ClusterIP
  ports:
    - port: 50000
      targetPort: 50000
  selector:
    app: jenkins

Launch Rancher in browser. Import an existing cluster. Add name to the cluster.

Run the command on the Kubernetes cluster generated by Rancher - 

curl --insecure -sfL https://localhost/v3/import/rspfgl98c4cdz8tqgpmls9znkfmrsx62whbpt7qls5crccf25vzqcs.yaml | kubectl apply -f -


Other way - Installing Jenkins using Helm in Kubernetes cluster -

kubectl -n kube-system create serviceaccount tiller

[root@oc2717564268 dashboard]# kubectl create clusterrolebinding tiller --clusterrole cluster-admin --serviceaccount=kube-system:tiller
clusterrolebinding.rbac.authorization.k8s.io/tiller created

helm init --service-account tiller

Output -

Creating /root/.helm 
Creating /root/.helm/repository 
Creating /root/.helm/repository/cache 
Creating /root/.helm/repository/local 
Creating /root/.helm/plugins 
Creating /root/.helm/starters 
Creating /root/.helm/cache/archive 
Creating /root/.helm/repository/repositories.yaml 
Adding stable repo with URL: https://kubernetes-charts.storage.googleapis.com 
Adding local repo with URL: http://127.0.0.1:8879/charts 
$HELM_HOME has been configured at /root/.helm.

Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.

Please note: by default, Tiller is deployed with an insecure 'allow unauthenticated users' policy.
To prevent this, run `helm init` with the --tiller-tls-verify flag.
For more information on securing your installation see: https://docs.helm.sh/using_helm/#securing-your-helm-installation
Happy Helming!
[root@oc2717564268 dashboard]# 

Tiller container getting created and running -

[root@oc2717564268 dashboard]# kubectl -n kube-system get pods
NAME                                    READY   STATUS              RESTARTS   AGE
coredns-699f8ddd77-gqzjv                0/1     ContainerCreating   0          33h
coredns-699f8ddd77-nzkp8                1/1     Running             0          33h
kubernetes-dashboard-6cc7d7f97f-kfq5z   0/1     CrashLoopBackOff    309        25h
tiller-deploy-7dc9577bfd-5qqx2          1/1     Running             0          103s
[root@oc2717564268 dashboard]# 

helm search jenkins

We see an application from the stable repository - 

NAME          	CHART VERSION	APP VERSION	DESCRIPTION                                                 
stable/jenkins	1.3.5        	lts        	Open source continuous integration server. It supports mu...
[root@oc2717564268 dashboard]# 

[root@oc2717564268 dashboard]# helm install stable/jenkins

$helm inspect values stable/jenkins > /tmp/jenkins.values

Edit configuration details in /tmp/jenkins.values - set rbac to true; edit resource requests - CPU, Memory

helm install stable/jenkins --values /tmp/jenkins.values --name myjenkins
pe:
[root@oc2717564268 dashboard]# kubectl get all
NAME                                         READY   STATUS    RESTARTS   AGE
pod/mothy-cheetah-jenkins-594895cc5d-xnwgs   0/1     Pending   0          52m
pod/myjenkins-5fd45bc594-5rjlv               0/1     Pending   0          75s


NAME                                  TYPE           CLUSTER-IP    EXTERNAL-IP   PORT(S)          AGE
service/kubernetes                    ClusterIP      10.32.0.1     <none>        443/TCP          35h
service/mothy-cheetah-jenkins         LoadBalancer   10.32.0.207   <pending>     8080:30116/TCP   52m
service/mothy-cheetah-jenkins-agent   ClusterIP      10.32.0.4     <none>        50000/TCP        52m
service/myjenkins                     LoadBalancer   10.32.0.48    <pending>     8080:32642/TCP   76s
service/myjenkins-agent               ClusterIP      10.32.0.223   <none>        50000/TCP        76s


NAME                                    DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/mothy-cheetah-jenkins   1         1         1            0           52m
deployment.apps/myjenkins               1         1         1            0           77s

NAME                                               DESIRED   CURRENT   READY   AGE
replicaset.apps/mothy-cheetah-jenkins-594895cc5d   1         1         0       52m
replicaset.apps/myjenkins-5fd45bc594               1         1         0       78s


Access Jenkins on the browser - Credentials - Jenkins - Global credentials - Add credentials - Kind: Kubernetes Service Account - Scope: Global - Ok

Jenkins - Manage Jenkins - Configure system - Credentials - Secret text - Add; Kubernetes URL and Jenkins URL autofilled. Test connection after verifying the details. Save.

Create a test job - demo-job - ok - Type: freestyle project - Build - Add a build step -

echo Hi this is from inside the container
hostname
sleep 20

Save - Build Now - Slave pod created. Verify by checking console output.

Jenkins pod gets terminated after executing the job.
